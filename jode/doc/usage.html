<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">
<html>
<head>
<title>Java Optimize and Decompile Environment (JODE)</title>
<meta name="robots" content="noindex">
<meta name="date" content="1999-10-24">
</head>

<body>
<table cellpadding=4 cellspacing=1 width=100%>
<tr>
<td></td>
<td> <img src="jode-logo.gif" alt="JODE" width=286 height=110></td>
</tr>
<tr>
<td valign="top">
<B><a href="http://www.informatik.uni-oldenburg.de/~delwi">Homepage</a></B>
<br><br>
<a href="jode.html"><B>Jode</B></a>
<ul>
<li><a href="applet.html">Test It Online</a></li>
<li><a href="download.html">Download</a></li>
<li>Usage<br>
<a href="#decompiler">Decompiler</a><br>
&nbsp;&nbsp;&nbsp;<a href="#cmdline">Command&nbsp;Line</a><br>
&nbsp;&nbsp;&nbsp;<a href="#awt">AWT&nbsp;Interface</a><br>
&nbsp;&nbsp;&nbsp;<a href="#swing">Swing&nbsp;Interface</a><br>
<a href="#optimizer">Obfuscator</a><br>
</li><br>
<li><a href="license.html">License</a></li>
<li><a href="history.html">History</a></li>
</ul>
</td>
<td>
<a name="decompiler">
<h1>Using the Decompiler</h1></a>
After you have <a href="download.html">downloaded</a> the necessary
packages, put them into your <tt>CLASSPATH</tt>:

<ul><li>Under Windows you have to start a MSDOS session and type
something like:
<pre>
set CLASSPATH=C:\download\jode-xxx.jar;C:\swing\swingall.jar
</pre>
</li><li>Under Unix you start a shell and type (for bourne shell):
<pre>export CLASSPATH=/tmp/jode-xxx.jar:/usr/local/swing/swingall.jar</pre>
or for csh:
<pre>setenv CLASSPATH /tmp/jode-xxx.jar:/usr/local/swing/swingall.jar</pre>
</ul>

<a name="cmdline"><h3>Command Line Interface</h3></a>

The most powerful way to start <I>JODE</I>'s decompiler is the command
line interface.  Some people don't like long command lines; they
should go to the next section. <br>

Start the class <tt>jode.Decompiler</tt> with the options.  The
following command will give a complete list of the available commands:

<pre>java jode.Decompiler --help</pre>

<a name="awt"><h3>AWT Interface</h3></a>

The AWT Interface looks exactly like the <a
href="applet.html">applet</a>.  In fact the applet uses the AWT
Interface. You start it after setting the <tt>CLASSPATH</tt> (see <a
href="#decompiler">above</a>), with
<pre>java jode.JodeWindow</pre>

In the classpath line you can enter a number of jar files, zip files
and directories separated by comma(<tt>,</tt>). Then enter the
dot(<tt>.</tt>) separated name of the class you want to decompile.
Press the <code>start</code> button and the decompiled class should
appear.  You can save it via the <code>save</code> button.

<a name="swing"><h3>Swing Interface</h3></a>

For the swing interface you need java version 1.2 or the separately
available swing package (see <a href="download.html#swing">download
page</a>. <br>

The swing interface will show the package hierarchie of all classes
in the classpath on the left side.  You can now select a class and the
decompiled code will appear on the right side.  Via the menu, you may
change the classpath or switch between package hierarchie tree and
class inheritence tree.<br>

The swing interface is very nice, if you just want to work how
something works, and you don't have the source code.  It is especially
useful to trace bugs through library code.  It is not meant to
generate <tt>java</tt> files and so you won't find a save option
there.<br>

<a name="optimizer"><h1>Using the Obfuscator</h1>

To use the obfuscator you have to create a script file, say <a
href="myproject.jos"><tt>myproject.jos</tt></a>, with
the following contents (You have to adapt it to match your project, of
course).  It should contain the following options:

<p>First select what you want to strip.  There are several
possibilities, which can be separated by comma(<tt>,</tt>):</p>
<dl>
<dt>unreach</dt>
<dd>strip unreachable methods and classes.</dd>
<dt>source</dt>
<dd>remove the name of the java file (exceptions will get unreadable).</dd>
<dt>lnt</dt>
<dd>remove the line number table (exceptions will get unreadable).</dd>
<dt>lvt</dt>
<dd>remove the local variable table (debugging doesn't work).</dd>
<dt>inner</dt>
<dd>strip inner class info (reflection doesn't work correctly).</dd>
</dl>
<pre>
strip = "unreach","lvt","inner"
</pre>

<p>Select the packages and classes you want to obfuscate.  You
should only include libraries, that you don't ship separately.</p>
<pre>
load = new WildCard { value = "org.myorg.myproject" },
       new WildCard { value = "org.myorg.mylib*" },
       new WildCard { value = "org.otherorg.shortlib" }
</pre>

<p>Select the methods and classes you want to preserve.  This is
the <tt>main</tt> method for applications and the default constructor
<tt>&lt;init&gt;.()V</tt> for applets, resource bundles and other classes
that you load manually at runtime.<br> You have to give the method
name and the type signature to identify your method.  <tt>javap
-s</tt> will show you the type signatures for your classes, but you
may also use <tt>*</tt>, to select all methods with that name.</p>
<pre>
preserve = new WildCard { value = "org.myorg.application.main.*" },
           new WildCard { value = "org.myorg.applet.&lt;init&gt;.()V" },
           new WildCard { value = "org.resources.bundle*.&lt;init&gt;.()V" }
</pre>

<p>If you want to obfuscate (or just shorten) the identifier you can
specify a renamer.  There are currently following renamer
available</p>
<dl><dt>StrongRenamer</dt>
<dd>Renames to the shortest possible name.  You can give a charset
that should be used.  It uses the same name as much as possible.</dd>
<dt>UniqueRenamer</dt>
<dd>Renames to unique identifier of the form <tt>xxx123</tt>.  Useful
to reduce name conflicts, before you decompile an obfuscated package.</dd>
<dt>NameSwapper</dt>
<dd>This renamer just swaps the names.  This is a funny obfuscation
option that is not very strong, but very confusing.</dd>
<dt>KeywordRenamer</dt>
<dd>Renames identifiers to keyword.  You can give your own list of
keywords as parameters.  Resulting code is not decompilable directly,
but it is legal bytecode.</dd>
</dl>
<pre>
renamer = new KeywordRenamer
</pre>


<p>Now you can select the analyzer.  The purpose of the
analyzer is to mark all reachable methods, find out which methods
needs to get the same name (overloading), and which method names
mustn't change (overload of library methods, e.g. <tt>nextElement</tt>
for <tt>Enumeration</tt>s). There are currently two analyzers.
<dl><dt>SimpleAnalyzer</dt>
<dd>Straight forward analyzer.  It is fast and will remove dead code
on method basis.</dd>
<dd><dt>ConstantAnalyzer</dt>

<dd>Strong analyzer that will determine, which fields and instructions
have constant values.  It will remove dead code on instruction basis
and replace constant instruction with a load constant, or remove them
completely.<br> This analyzer is especially useful to revert Zelix
Klassmaster's flow obfuscation.</dd>
</dl>
</p>
<pre>
analyzer = new SimpleAnalyzer
</pre>

<p>Pre- and Post transformers transform the bytecode before
resp. after the Analyzer runs.  Using this defaults should be
okay.</p>
<pre>
post = new LocalOptimizer, new RemovePopAnalyzer
</pre>

</td>
</table>

<hr>

<p><A HREF="mailto:Jochen.Hoenicke@Informatik.Uni-Oldenburg.DE">
http://www.informatik.uni-oldenburg.de/~delwi/jode/usage.html</A>, last
updated on <em>24-Okt-1999</em>.</p>

</body>
</html>

